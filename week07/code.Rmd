---
title: "Week 7 #RecreationThursday"
author: "Jiwan Heo"
output: html_document
---

Flow field with circle-line collision. Scroll down to line 63 for explanation!

```{r setup}
# library(tidyverse) # Trying my luck with namespace here!
# library(ambient)
# library(ggforce)
library(magrittr) # oh well

source(here::here("week07", "my-functions", "call_everything.R"))
source(here::here("week07", "my-functions", "generate_flow_field.R"))
source(here::here("week07", "my-functions", "start_particles.R"))
source(here::here("week07", "my-functions", "draw_curve.R"))
source(here::here("week07", "my-functions", "step_into_next_curve_segment.R"))
source(here::here("week07", "my-functions", "line_to_circle_collision.R"))
source(here::here("week07", "my-functions", "closest_point_on_line.R"))
source(here::here("week07", "my-functions", "colour_assign.R"))
source(here::here("week07", "my-functions", "plotter.R"))
```

# Code
              
```{r}
circles <- list(
  list(
    list(x0 = 200, y0 = 800, r = 80, padding = 1),
    list(x0 = 500, y0 = 500, r = 80, padding = 1),
    list(x0 = 800, y0 = 200, r = 80, padding = 1)
  ) 
)
```

```{r}
current_time <- format(Sys.time(), "%Y-%m-%d_%H-%M-%S")

my_plots <- tibble::tibble(
  flow_field_width = 1000,
  resolution_factor = 0.02,
  perlin_scale_factor = 0.00375,
  perlin_seed = 52,
  perlin_freq = 0.01,
  n_out = 1500,
  num_steps = 300,
  step_length = 0.1,
  circles = circles,
  background_clr = "#221e1b", #554135  #2b1c12 #251d18
  clr1 = "#b3142c",
  clr2 = "#ffffff",
  max_clr_prob = 0.99999,
  border_length = 0.1,
  current_time = current_time,
  plot_save = TRUE
) %>%
  dplyr::mutate(row_num = dplyr::row_number()) %>% 
  purrr::pmap(call_everything)
```

# Workflow

`call_everything`(flow_field_width,
                  resolution_factor,
                  perlin_scale_factor,
                  perlin_seed,
                  perlin_freq, 
                  
                  n_out,
                  num_steps,
                  step_length,       
                  circles,
                  
                  clr1,
                  clr2,
                  max_clr_prob,
                  
                  background_clr,
                  border_length,          
                  current_time,
                  plot_save,
                  row_num)
                
is a function that takes in a bunch of parameters and passes them down to subsequent functions to be called. 

- It returns: list(plot = a ggplot object, the drawing!, 
                   plot_name = string that contains parameter combinations, 
                   flowed_curves = the curves being drawn)
                   
- calls the following functions in order:
    1. `generate_flow_field`(flow_field_width = 1000, 
                             resolution_factor = 0.025,
                             perlin_scale_factor = 0.005,
                             perlin_seed,
                             perlin_freq)
                           
        - sets up a rectangular grid, with granularity controlled by `resolution_factor`
        - with the 3 perlin parameters, generate perlin noise, and scale them to fit between 0 ~ 2*pi (will use as angles)
        - going to store this as a matrix (`my_flow_field`). We'll use the matrix index to lookup angles.
          - will also save a tidy version (`visualized_flow_field`), compatible with geom_segment 
        - let's save `list(my_flow_field, visualized_flow_field)`. We'll pass `my_flow_field` into `start_particles()`
      
    2. `start_particles`(n_out = 800,
                         flow_field_width,
                         num_steps,  
                         step_length,
                         flow_field,
                         resolution_factor,
                         circles)
                               
        - define some x/y combinations that represent the starting point of the curves.
        - for each combination (row in a tibble is pmap'd), call `draw_curve`
    
    2-1 `draw_curve`(start_x, 
                     start_y, 
                     row_num, 
                     flow_field, 
                     resolution, 
                     left_x     = 1 * resolution, # actual grid bottom-left coords
                     bot_y      = 1 * resolution,
                     num_steps,   # This controls how smooth/curvy the line is
                     step_length, # This controls how far the line should go each step
                     circles)
    - This function generates the curves, influenced by flow fields.
    - We have 2 things going on at the same time
      1. Simulating particle movement on flow field as a curve, made with many short lines,
      2. Collision check of the curve with circles. (If at any point of curve generation, it crosses a circle, stop plotting that line.)
      
    - Steps: 
      - Check if the fed starting points overlap with any circles. If so, discard and move to next x/y combination.
      - If not, save it as a first item in a vector with length: `num_steps + 1`. 
      - Feed x/y coordinates into `step_into_next_curve_segment()` to get a second point, to form a line. 
      - Check if the line formed between the current & destination points crosses any circles. 
      - If so, don't plot this destination point, and move to the next x/y combination.
      - If not, keep iterating until it finishes, or runs into a circle.
      
    2-2 `step_into_next_curve_segment`(start_x, 
                                       start_y,
                                       left_x,
                                       bot_y,
                                       resolution,
                                       x_dim_range,
                                       y_dim_range,
                                       flow_field,
                                       step_length)          
    - Scale the x/y location back down to the `flow_field` grid dimension, and grab the closest item (angles generated with perlin noise)
    - Extend the current x/y at this angle, by `step_length` amount. 
    - return the calculated x/y positions.
                               
    2-3 `line_to_circle_collision`(line_x, line_y, line_xend, line_yend,
                                   circle_x, circle_y, circle_r)    
    - checks if a given line crosses a given circle, and returns a TRUE/FALSE boolean with the help of `closest_point_on_line`.
    
    2-4 `closest_point_on_line`(start_x, start_y, end_x, end_y, 
                                point_x, point_y) 
    - Finds the closest point on a line segment, to a given target point.
    - This distance is compared to a circle radius in `line_to_circle_collision`
    - implementation of https://diego.assencio.com/?index=ec3d5dfdfc0b6a0d147a656f0af332bd
    
    3. `colour_assign`(flowed_curves,
                       clr1, 
                       clr2, 
                       max_clr_prob)
    
    - After the curve has been calculated, sample 2 colours based on mean y position of the curve.
    - Returns `list(assigned_clrs, palette)`. 
      - `assigned_clrs` is a tibble, with row_num <-> clr combination, to be joined on `flowed_curves`
      - `palette` is a named vector to be passed to `plotter()`, to be used in `scale_color_manual()`
                               
    4. `plotter`(background_clr,
                 circle_clr,
                 flow_field_width,
                 border_length,
                 flow_field_outline, 
                 flow_field_curves,
                 circles,
                 row_num,
                 clr_palette)
        - takes in the flow field, ff'd curves, and the circles, to plot!
        - transforming the `circles` from a list of lists to a tibble, before feeding it in. (Maybe I'll eventually find an efficient way!)
          
          