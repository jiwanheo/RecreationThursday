---
title: "Untitled"
output: html_document
---

Flow field is defined as a grid, with **dimension**: num_cols x num_rows, with each item containing an angle.
This grid is **sized up**, and a canvas (bigger in size) is created

Let's do some collision checks 
- lines: kinda hard
- shape: let's try circle, and stop line when collide.
  - making some progress here.


I like seed 57, 66, 76 vs something like 17

```{r setup}
# library(tidyverse) # Trying my luck with namespace here!
# library(ambient)
# library(ggforce)
library(magrittr) # oh well


source(here::here("week07", "my-functions", "generate_flow_field.R"))
source(here::here("week07", "my-functions", "draw_curve.R"))
source(here::here("week07", "my-functions", "step_into_next_curve_segment.R"))
source(here::here("week07", "my-functions", "calculate_flow_fields.R"))
source(here::here("week07", "my-functions", "plotter.R"))
source(here::here("week07", "my-functions", "call_everything.R"))
source(here::here("week07", "my-functions", "closest_point_on_line.R"))
source(here::here("week07", "my-functions", "line_to_circle_collision.R"))
```

# Code
              
```{r}
circles <- list(
  list(
    list(x0 = 300, y0 = 500, r = 200),
    list(x0 = 900, y0 = 500, r = 50)
  ) 
)

my_plots <- tibble::tibble(
  flow_field_width = 1000,
  resolution_factor = 0.05,
  perlin_scale_factor = 0.0001,
  perlin_seed = 89431,
  perlin_freq = 5,
  n_out = 500,
  num_steps = 800,
  step_length = 0.04,
  circles = circles
) %>%
  purrr::pmap(call_everything)

print(my_plots[[1]][[1]])

my_plots[[1]][[3]]
```

```{r}
# current_time <- format(Sys.time(), "%Y-%m-%d_%H-%M-%S")
# 
# my_plots <- crossing(
#   ff_size = 1000,
#   resolution_factor = runif(n = 3, 0.005, 0.05),
#   perlin_scale_factor = runif(n = 3, 0.001, 0.01),
#   perlin_seed = sample(1:99999, size = 3),
#   perlin_freq = 5,
#   num_steps = c(2:8),
#   step_length = sample(5:10)
# ) %>%
#   pmap(call_everything)
# 
# walk(my_plots,
#      ~ggsave(
#        here::here("week07", "progress", current_time, .x$plot_name),
#        plot      = .x$plot,
#        device    = ragg::agg_png,
#        res       = 100,
#        units     = "in",
#        width     = 1000,
#        height    = 1000,
#        limitsize = FALSE
#      ))
```

# Workflow

`call_everything`(flow_field_width,
                  resolution_factor,
                  perlin_scale_factor,
                  perlin_seed,
                  perlin_freq, 
                  n_out,
                  num_steps,
                  step_length,       
                  circles)
                
is a function that takes in a bunch of parameters and passes them down to subsequent functions to be called. 

- It returns: list(plot = a ggplot object, the drawing!, 
                   plot_name = string that contains parameter combinations, 
                   flowed_curves = the curves being drawn)
                   
- calls the following functions in order:
    1. `generate_flow_field`(flow_field_width = 1000, 
                             resolution_factor = 0.025,
                             perlin_scale_factor = 0.005,
                             perlin_seed,
                             perlin_freq)
                           
        - sets up a rectangular grid, with granularity controlled by `resolution_factor`
        - with the 3 perlin parameters, generate perlin noise, and scale them to fit between 0 ~ 2*pi (will use as angles)
        - going to store this as a matrix (`my_flow_field`). We'll use the matrix index to lookup angles.
          - will also save a tidy version (`visualized_flow_field`), compatible with geom_segment 
        - let's save `list(my_flow_field, visualized_flow_field)`. We'll pass `my_flow_field` into `calculate_flow_fields()`
      
    2. `calculate_flow_fields`(n_out = 800,
                               flow_field_width,
                               num_steps,  
                               step_length,
                               flow_field,
                               resolution_factor,
                               circles)
                               
        - define some x/y combinations that represent the starting point of the curves.
        - for each combination (row in a tibble is pmap'd), call `draw_curve`
    
    2-1 `draw_curve`(start_x, 
                     start_y, 
                     row_num, 
                     flow_field, 
                     resolution, 
                     left_x     = 1 * resolution, # actual grid bottom-left coords
                     bot_y      = 1 * resolution,
                     num_steps,   # This controls how smooth/curvy the line is
                     step_length, # This controls how far the line should go each step
                     circles)
    - This function generates the curves, influenced by flow fields.
    - We have 2 things going on at the same time
      1. Simulating particle movement on flow field as a curve, made with many short lines,
      2. Collision check of the curve with circles. (If at any point of curve generation, it crosses a circle, stop plotting that line.)
      
    - Steps: 
      - Check if the fed starting points overlap with any circles. If so, discard and move to next x/y combination.
      - If not, save it as a first item in a vector with length: `num_steps + 1`. 
      - Feed x/y coordinates into `step_into_next_curve_segment()` to get a second point, to form a line. 
      - Check if the line formed between the current & destination points crosses any circles. 
      - If so, don't plot this destination point, and move to the next x/y combination.
      - If not, keep iterating until it finishes, or runs into a circle.
      
    2-2 `step_into_next_curve_segment`(start_x, 
                                       start_y,
                                       left_x,
                                       bot_y,
                                       resolution,
                                       x_dim_range,
                                       y_dim_range,
                                       flow_field,
                                       step_length)          
    - Scale the x/y location back down to the `flow_field` grid dimension, and grab the closest item (angles generated with perlin noise)
    - Extend the current x/y at this angle, by `step_length` amount. 
    - return the calculated x/y positions.
                               
    2-3 `line_to_circle_collision`(line_x, line_y, line_xend, line_yend,
                                   circle_x, circle_y, circle_r)    
    - checks if a given line crosses a given circle, and returns a TRUE/FALSE boolean with the help of `closest_point_on_line`.
    
    2-4 `closest_point_on_line`(start_x, start_y, end_x, end_y, 
                                point_x, point_y) 
    - Finds the closest point on a line segment, to a given target point.
    - This distance is compared to a circle radius in `line_to_circle_collision`
    - implementation of https://diego.assencio.com/?index=ec3d5dfdfc0b6a0d147a656f0af332bd
                               
    3. `plotter`(background_clr = "#e7e2df",
                 line_clr = "#914062",
                 circle_clr = "#a48370",
                 flow_field_width,
                 flow_field_outline, 
                 flow_field_curves,
                 circles)
        - takes in the flow field, ff'd curves, and the circles, to plot!
        - transforming the `circles` from a list of lists to a tibble, before feeding it in. (Maybe I'll eventually find an efficient way!)
          
          