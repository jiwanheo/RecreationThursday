---
title: "Untitled"
output: html_document
---

Flow field is defined as a grid, with **dimension**: num_cols x num_rows, with each item containing an angle.
This grid is **sized up**, and a canvas (bigger in size) is created

I like seed 57, 66, 76 vs something like 17

```{r}
library(tidyverse)
library(ambient)

generate_flow_field <- function(ff_size = 1000, 
                                resolution_factor = 0.025,
                                perlin_scale_factor = 0.005,
                                perlin_seed,
                                perlin_freq) {
  
  # Flow field grid dimension
  resolution <- ff_size * resolution_factor # This should be a parameter
  num_cols <- ff_size %/% resolution
  num_rows <- num_cols
  
  # Generating perlin noise
  long_grid_ff <- long_grid(x = 1:num_cols,
                            y = 1:num_rows) %>% 
    mutate(x = x * perlin_scale_factor,
           y = y * perlin_scale_factor) %>% 
    mutate(angle = gen_perlin(x, y,
                              seed = perlin_seed,
                              frequency = perlin_freq))
  
  min_per <- min(long_grid_ff$angle)
  max_per <- max(long_grid_ff$angle)
  
  # normalize angles to be between 0 & 2pi
  long_grid_ff <- long_grid_ff %>% 
    mutate(angle = (angle-min_per) / (max_per-min_per) *  (2*pi-0) + 0)
  
  my_flow_field <- matrix(data = long_grid_ff$angle,
                          ncol = num_cols,
                          nrow = num_rows)
  
  
  visualized_flow_field <- crossing(
    x = 1:num_cols,
    y = 1:num_rows
  ) %>% 
    # Look up the angles in the matrix at the x/y cols
    mutate(angle = map2_dbl(x, y, ~my_flow_field[[.y, .x]])) %>% 
    mutate(xend = x + cos(angle) * 0.5,
           yend = y + sin(angle) * 0.5) %>% 
    mutate(x_index = x, y_index = y) %>% 
    mutate(across(c(x, y, xend, yend), ~ .x * resolution))
  
  
  list(my_flow_field, visualized_flow_field)
}
```

```{r}
draw_curve <- function(start_x, 
                       start_y, 
                       row_num, 
                       flow_field = my_flow_field, 
                       resolution, 
                       left_x     = 1 * resolution, # actual grid bottom-left coords
                       bot_y      = 1 * resolution,
                       num_steps,   # This controls how smooth/curvy the line is
                       step_length) # This controls how far the line should go each step
{ 
  
  x_dim_range <- 1:ncol(flow_field) # get the grid dimension to lookup the angles. 
  y_dim_range <- 1:nrow(flow_field)
  
  # Record x/y movements in the flow field. (Initialize with the starting points)
  x_container <- vector("numeric", num_steps + 1)
  y_container <- vector("numeric", num_steps + 1)
  
  x_container[1] <- start_x
  y_container[1] <- start_y
  
  
  # With the rest of num_steps, move through the flow field, with the closest angle we can grab.
  for (i in 1:num_steps) {
    
    # Get the current x/y position (in relation to grid size)
    x_offset <- start_x - left_x
    y_offset <- start_y - bot_y
    
    # Scale it down, to match grid dimension
    curr_x_index <- round(x_offset / resolution, digits = 0)
    curr_y_index <- round(y_offset / resolution, digits = 0)
    
    # Find the closest point on the grid at each x/y 
    closest_x_index <- which(abs(x_dim_range - curr_x_index) == min(abs(x_dim_range - curr_x_index)))
    closest_y_index <- which(abs(y_dim_range - curr_y_index) == min(abs(y_dim_range - curr_y_index)))
    
    # Grab that angle
    closest_angle <- flow_field[[closest_y_index, closest_x_index]]
    
    # Extend the current line into that angle (scale it up again)
    x_step  <- step_length * cos(closest_angle) * resolution
    y_step  <- step_length * sin(closest_angle) * resolution
    start_x <- start_x + x_step
    start_y <- start_y + y_step
    
    # And record
    x_container[i+1] <- start_x
    y_container[i+1] <- start_y
    
  }
  
  tibble(
    x = x_container,
    y = y_container,
    row_num = row_num
  )
  
}
```

```{r}
calculate_flow_fields <- function(n_out = 800,
                                  width = 1000,
                                  num_steps,  
                                  step_length,
                                  ff,
                                  resolution_factor) 
{
  df <- tibble(
    start_x = runif(-width*0.1, width*1.1, n = n_out),
    start_y = runif(-width*0.1, width*1.1, n = n_out)
  ) %>%
    mutate(row_num = row_number(),
           resolution = width * resolution_factor,
           num_steps = num_steps,
           step_length = step_length)
  
  df %>% 
    pmap_dfr(draw_curve, 
             flow_field = ff)
}
```

```{r}
plotter <- function(background_clr = "#e7e2df",
                    line_clr = "#914062",
                    ff_size,
                    ff_outline, 
                    ff_res
) 
{
  
  # The actual size of the flow field
  ff_width <- ff_size
  ff_height <- ff_size
  
  # Canvas size (bigger than flow field)
  canvas_left_x <- ff_width * -0.5
  canvas_right_x <- ff_width * 1.5
  canvas_top_y <- ff_height * -0.5
  canvas_bottom_y <- ff_height * 1.5
  
  ggplot() +
    geom_segment(data = ff_outline,
                 aes(x = x, 
                     y = y,
                     xend = xend,
                     yend = yend),
                 color = "grey70") +
    geom_path(data = ff_res,
              aes(x = x,
                  y = y,
                  group = row_num),
              colour = line_clr) +
    coord_equal(xlim = c(canvas_left_x, canvas_right_x),
                ylim = c(canvas_top_y, canvas_bottom_y)) +
    theme_void() +
    theme(
      plot.background = element_rect(fill = background_clr,
                                     color = background_clr)
    )
}
```

```{r}
call_everything <- function(ff_size,
                            resolution_factor,
                            perlin_scale_factor,
                            perlin_seed,
                            perlin_freq,
                            
                            num_steps,
                            step_length) 
{
  flow_fields <- generate_flow_field(ff_size = ff_size, 
                                     resolution_factor = resolution_factor,
                                     perlin_scale_factor = perlin_scale_factor,
                                     perlin_seed = perlin_seed,
                                     perlin_freq = perlin_freq)
  
  my_curves <- calculate_flow_fields(num_steps = num_steps, 
                                     step_length = step_length,
                                     ff = flow_fields[[1]],
                                     resolution_factor = resolution_factor)
  
  my_plot <- plotter(ff_size = ff_size,
                     ff_outline = flow_fields[[2]],
                     ff_res = my_curves)
  
  plot_name <- paste("ff_size", ff_size, 
                     "resolution_factor", round(resolution_factor, digits = 5), 
                     "perlin_scale_factor", round(perlin_scale_factor, digits = 5),
                     "perlin_seed", perlin_seed,
                     "perlin_freq", perlin_freq,
                     "num_steps", num_steps,
                     "step_length", round(step_length, digits = 5),
                     ".png")
  
  list(plot = my_plot, plot_name = plot_name)
}

nums <- 10

my_plots <- crossing(
  ff_size = 1000,
  resolution_factor = runif(n = 1, 0.005, 0.05),
  perlin_scale_factor = runif(n = 1, 0.001, 0.01),
  perlin_seed = 67,
  perlin_freq = 5,
  num_steps = runif(n = 1, 500, 1000), 
  step_length = runif(n = 1, 0.01, 0.03)
) %>%
  pmap(call_everything)

current_time <- format(Sys.time(), "%Y-%m-%d_%H-%M-%S")

walk(my_plots,
     ~ggsave(
       here::here("week07", "progress", current_time, .x$plot_name),
       plot      = .x$plot,
       device    = ragg::agg_png,
       res       = 100,
       units     = "in",
       width     = 1000,
       height    = 1000,
       limitsize = FALSE
     ))
```

