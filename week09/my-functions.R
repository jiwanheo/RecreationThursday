# returns a geom_polygon-friendly tibble that draws a square grid with gutter.
generate_initial_grid_coords <- function(num_row, square_thickness=1, grid_thickness=0.2) {
  
  small_coords <- accumulate(1:num_row, ~(.y*square_thickness) + grid_thickness*(.y-1))
  big_coords   <- small_coords + square_thickness
  
  crossing(
    tibble(x = small_coords, xend = big_coords),
    tibble(y = small_coords, yend = big_coords)
  )
}

# takes a pair of x/xend or y/yend, shrink it, and return the new values in a named list
shrink_grid_coords <- function(small_coord, big_coord, shrink_by, x_or_y) {
  coord_mean <- (small_coord + big_coord)/2
  shrink_amt <- (big_coord-coord_mean) * shrink_by
  
  new_small_coord <- coord_mean - shrink_amt
  new_big_coord   <- coord_mean + shrink_amt
  
  output_list <- list(new_small_coord, new_big_coord)
  set_names(output_list, nm = c(x_or_y, paste0(x_or_y, "end")))
}

# take the geom_friendly format, and explicitly build out the vertices.
make_vertices <- function(x, xend, y, yend, square_id) {
  
  tribble(
    ~x,   ~y,   ~vertex, ~square_id,
    x,    y,    "bot_l", square_id,
    x,    yend, "top_l", square_id,
    xend, yend, "top_r", square_id,
    xend, y,    "bot_r", square_id
  )
  
}

# generate the starting points of the gradient lines in a side of a square (flexible x/y)
get_gradient_points <- function(x, y, vertex, square_id, dat, n_lines) {
  
  target_direction <- switch(vertex,
                             "bot_l" = list(next_vertex = "top_l", move_along = "y"),
                             "top_l" = list(next_vertex = "top_r", move_along = "x"),
                             "top_r" = list(next_vertex = "bot_r", move_along = "y"),
                             "bot_r" = list(next_vertex = "bot_l", move_along = "x")
  )
  
  target_criteria <- which(dat$vertex == target_direction$next_vertex & dat$square_id == square_id)
  target_loc <- dat[[target_criteria, target_direction$move_along]]
  
  hold_constant <- if(target_direction$move_along == "x") "y" else "x" 
  
  starting_loc <- eval(sym(target_direction$move_along)) #cheeky way to get the passed x/y in the arg.
  moving <- seq(starting_loc, target_loc, length.out = n_lines)
  
  out_list <- list(
    moving, 
    rep(eval(sym(hold_constant)), n_lines), 
    rep(vertex, n_lines),
    rep(square_id, n_lines),
    1:n_lines
  )
  
  names(out_list) <- c(target_direction$move_along, hold_constant, "vertex", "square_id", "point_id")
  out_list
}

# First, connect the outer square's points to shrunk square's points, generated by `get_gradient_points`
# This gives me the angle to protrude towards to.
# With this angle, extend a random amount from the outer square, towards the shrunk square.
connect_gradient_points <- function(outer_points, shrunk_points, min_length) {
  outer_gradient <- tibble(
    x = do.call(c, map_depth(outer_points, 1, "x")),
    y = do.call(c, map_depth(outer_points, 1, "y")),
    vertex = do.call(c, map_depth(outer_points, 1, "vertex")),
    square_id = do.call(c, map_depth(outer_points, 1, "square_id")),
    point_id = do.call(c, map_depth(outer_points, 1, "point_id"))
  )
  
  shrunk_gradient <- tibble(
    xend = do.call(c, map_depth(shrunk_points, 1, "x")),
    yend = do.call(c, map_depth(shrunk_points, 1, "y")),
    vertex = do.call(c, map_depth(shrunk_points, 1, "vertex")),
    square_id = do.call(c, map_depth(shrunk_points, 1, "square_id")),
    point_id = do.call(c, map_depth(shrunk_points, 1, "point_id"))
  )
  
  outer_gradient %>% 
    inner_join(shrunk_gradient, by = c("vertex", "square_id", "point_id")) %>% 
    mutate(angle = atan2(x = (xend-x), y = (yend-y)),
           max_length = sqrt((xend-x)^2 + (yend-y)^2)) %>% 
    mutate(new_length = map_dbl(max_length, ~runif(n = 1, min = .x*min_length, max = .x))) %>% # 
    mutate(new_xend = x + cos(angle) * new_length,
           new_yend = y + sin(angle) * new_length) %>% 
    select(-c(xend, yend, max_length, new_length))
}